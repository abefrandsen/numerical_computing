\lab{Python}{Generators}{Generators}
\label{lab:Python_Generators}


\begin{problem}
Find the sum of the first four billion odd Fibonacci numbers that are divisible by 3.
\end{problem}


Python generators produce values of a sequence on demand.  When iterating over a large
sequence, generators a much more efficient.

\section*{Combinations}
Combinations are subsets of a set.  The powerset of a set, $S$, is the set of all combinations
of elements in $S$.  The cardinality of the the powerset is $2^{\abs{A}}$.  Clearly, if our
set is of any appreciable size, the powerset will much larger.  Let's look at one method for
generating the powerset of a set.

We can generate the powerset of a set by representing each element in a set by one bit.
If the bit is 0, then we do not include the element in the current combination.  If the
bit is 1, the element is included in the combination.  Then we count from 0 to $2^{\abs{A}}$
and look as the binary representation of the number, including or excluding elements based
on the bits in their respective location.

\begin{problem}
Write a function that will accept a set of elements and return a list of all the combinations
of elements of that set.  You will have to impose some sort of ordering on the set (map each element
in the set to a position in the binary representation).
\end{problem}

This is however an inefficient way to generate combinations.  Ideally, we would want
to generate the next combination by modifying the previous combination.  However, with
out current method of counting in binary, we are rebuilding the combination from scratch
each time.  For example it we have a combination represented by \texttt{01111}, the next
combination would be \texttt{10000}.  We added one element and removed four elements!
We want to get our next combination by changing the previous combination as little as possible.
Fortunately, there is a really neat method for doing this.  We now introduce you to
Gray codes.  Gray codes is a reflected binary code where each new code is generated by
changing the previous code by exactly one bit.  Geometrically, we can think of it as
traversing a unit cube by moving only along the edges of the cube.  Grey codes are used frequently
in error correction schemes.

A Gray code is constructed as follows~\footfullcite{brualdi09}.  To calculate the Gray code of order $n$:
\begin{enumerate}
\item The Gray code of order 1 is 0, 1.
\item Compute the Gray code of order $n-1$.  Write the codes and then write them again in reverse order (reflect them so that the last Gray code or order $n-1$ is first and the first Gray code of order $n-1$ is last).
\item Prepend a 0 to the first $n-1$ codes and prepend a 1 to the remaining $n-1$ codes.
\end{enumerate}
While this is a simple algorithm to describe, it is not very efficient.  
To generate a Gray code of order $n$, we have to generate all previous Gray codes.  
If we were to calculate the Gray codes up to order 6, we would calculate the Gray code of order 6 once, order 5 twice, order 4 three times, order 3 four times, and order 2 five times!
Fortunately, there exists another way to compute Gray codes of order $n$ much more efficiently.
The algorithm is given in Brualdi's book.  
We note first that a Gray code of order $n$ is of length $2n-2$ with each code of length $n$.
We also observe that the reflected gray codes always begin with $0\dots0$ and terminate with $10\dots0$.
\begin{enumerate}
\item Start with $0\dots0$ ($n$ zeros).  This is the current Gray code.
\item Sum the digits of the current Gray code.
\begin{enumerate}
\item If the sum of the digits is even, add 1 to the last digit mod 2.
This becomes our new current Gray and we go back to step 1.
\item If the sum of the digits is odd, locate digit $i$, where $i$ is the rightmost non-zero digit.  Add 1 to the $i-1$ digit mod 2.  This becomes our new current Gray and we go back to step 1.
\end{enumerate}
\end{enumerate}

\begin{problem}
Implement the algorithm above for calculating the Gray code of order $n$.
Your implementation must function as a generator.
\end{problem}

\begin{problem}
The Fundamental Theorem of Arithmetic.
Find all the factors of a number, $n$, using combinations.
\end{problem}




Use combinations to find all factors of n

Introduce itertools

\begin{problem}
\label{prob:subblocks}
Write a generator function that will evenly split a 1-dimensional array into sub-blocks.
Your function should be capable of returning sub-blocks that could possibly overlap.
The function should accept as arguments: a 1-dimensional array,
a block width, and an optional offset.  If array cannot be evenly divided into
sub-blocks, raise and error.
\end{problem}

\begin{problem}
Expand your solution to Problem \ref{prob:subblocks} to work with 2-dimensional and 3-dimensional
arrays.  You may implement them as separate functions if you wish.
\end{problem}

\printbibliography

% \begin{thebibliography}{99}
% \bibitem{brualdi09}
% Richard Brualdi, 
% \emph{Introductory Combinatorics}.
% Pearson, New Jersey, 5th edition, 2009.
% 
% \end{thebibliography}
