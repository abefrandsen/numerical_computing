\lab{Extensions}{Python Idioms}{Idiomatic Python}
\label{lab:Extensions_Idioms}

\objective{Learn various ways to do things efficiently in Python}

\begin{definition}[Idiom]
the style of expression in writing, speech, or music that is typical of a particular period, person, or group.
\end{definition}

Python has many powerful idioms that are very common.  The experienced Python programmer will at some point in time encounter these idioms.  The idioms discussed in this chapter take special advantage of the Python language to do things in a cleaner, more elegant, and often more efficient manner.  We will use the Zen of Python as a guide to the concepts discussed in this lab.

Lets begin:
\begin{lstlisting}
: import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
\end{lstlisting}

\section*{1. Beautiful is better than ugly}
\begin{lstlisting}
squares = []
for n in range(10):
    squares.append(n**2)
    
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{lstlisting}
In this example, we are constructing a list of the squares of the numbers 1 to 10.
Now lets add only the odd squares.
\begin{lstlisting}
oddsquares = []
for n in range(10):
    n = n**2
    if n%2 == 0:
        oddsquares.append(n)
        
[1, 9, 25, 49, 81]
\end{lstlisting}
In Python, both of these solutions are pretty clear and succinct.
However, each problems can solved respectively as follows
\begin{lstlisting}
squares = [x**2 for x in range(10)]
oddsquares = [x for x in squares if x%2 == 1]
\end{lstlisting}
These two solutions are known in Python as list comprehensions.
List comprehension syntax closely mirrors the mathematical form of set definition.

\section*{2. Explicit is better than implicit}
\begin{lstlisting}
from scipy import *
a = rand(10,10)
\end{lstlisting}

Importing things into the global namespace (more on that later) is not a good idea.

Things should be imported explicitly
\begin{lstlisting}
from scipy import rand as sprand
a = sprand(10,10)
\end{lstlisting}

\section*{3. Flat is better than nested}

\section*{4. Sparse is better than dense. Readability counts.}
\begin{lstlisting}
primes = [x for x in range(2, 50) if x not in [j for i in range(2,8) for j in range(i*2, 50, i)]]
\end{lstlisting}

\section*{5. Namespaces are one honking great idea -- let's do more of those!}
Two python objects cannot share the same name.  If two python objects happen to share a name,
one of the objects will override the other.  There is no notion of method overloading in Python.
In other languages two functions may share the same name if they accept different input arguments.
In Python, the most recently defined will override any method that shares the same name,
regardless of the input arguments.
\begin{lstlisting}
def random(x):
    return x**2+.5**.215%x
def random(y):
    return y**9**(1./3)-.52%y
\end{lstlisting}
In the code above, the second \li{random} function will override the first \li{random}.
After the second function is defined, the first function is completely inaccessible.
Now let's import Python's \li{random} module (\li{import random}).  Now \li{random} refers
to the module and not to our defined function.  This is where the concept of namespaces becomes important.
A namespace is a space or collections of names.  It is Python's method of keeping names from colliding.
Namespaces are defined in Python using modules.  We mention namespaces because, it not understood could be
a source of grief.  We illustrate with another example
\begin{lstlisting}
def add(x, y):
    return x*y/(x+y)
\end{lstlisting}
As you can see, our function clearly does add two numbers in the standard way.  There are three ways
to import Python modules.  We will use the SciPy library as an example.
\begin{enumerate}
\item \li{import scipy} imports all the functions in the SciPy namespace and places them in
the \li{scipy} namespace.  SciPy also has an add function which adds elements of two arrays.
This add function can be accessed by \li{scipy.add} while our version of add is still accessible by \li{add}.
If we don't want to always type \li{scipy.}, we can define an alias for the namespace by importing our module
with \li{import scipy as sp}.  Then we access SciPy's add function by \li{sp.add}.
\item \li{from scipy import add} will import SciPy's add function into the current namespace.  Our add function
will no longer be accessible after this import.  We can again define an alias by \li{from scipy import add as sadd}.
\item \li{from scipy import *} is highly discouraged as it provides no control over namespaces.  It will import all
functions in the SciPy namespace, clobbering any function in current namespace that shares the same name.
\end{enumerate}


\section*{Constructions}

\subsection*{Strings}
Strings are immutable object in Python.  As such, it is quite costly to concatenate strings using the \li{+} operator.
\begin{lstlisting}
: import string
: def concatStr(strs):
:     m = `'
:     for s in strs:
:         m += s
:     return m
: def accumStr(strs):
:     return `'.join(strs)
: timeit concatStr(list(string.letters))
100000 loops, best of 3: 3.03 us per loop
: timeit accumStr(list(string.letters))
1000000 loops, best of 3: 810 ns per loop
\end{lstlisting}
Notice that \li{accumStr} runs considerably faster.  What is actually happening in \li{concatStr} is that each time we add an element from \li{list(string.letters)}, Python has to reallocate the entire string in memory.  Not only is \li{accumStr} more efficient, but it is also significantly shorter.

Python has some really powerful string formatting options available.  More information is located at \url{http://www.python.org/dev/peps/pep-3101/}

\subsection*{Tuples}
Python creates tuples whenever the interpreter encounters a list of comma separated values.  This is called tuple packing.
\begin{lstlisting}
: a = 1, 2, 3, 4, 5
: print a, type(a)
(1, 2, 3, 4, 5) <type `tuple'>
\end{lstlisting}
We can also unpack a tuple into several variables
\begin{lstlisting}
: a, b, c = 1, 2, 3
: print a; print b; print c
1
2
3
\end{lstlisting}
We can take advantage of this to quickly swap the values of two variables.
\begin{lstlisting}
: a, b = 3, 5
: print a; print b
3
5
: b, a = a, b
: print a; print b
5
3
\end{lstlisting}
Note the following
\begin{lstlisting}
: (0,)
(0,)
: 0,
(0,)
: (0) #this is not a tuple!
0
: () #this is a special empty tuple
()
: tuple() #tuple constructor
()
\end{lstlisting}

\section*{Lists}
Lists are Python's workhorse datatype.  It is therefore highly useful to be able to quickly and efficiently construct and iterate through lists in Python.
\begin{lstlisting}
: [] #an empty list
[]
: list() #list constructor
[]
: [1] #list with one element
[1]
: [1, 2] #list more than one element
[1, 2]
\end{lstlisting}

\subsection*{List Constructions}
List comprehensions are a very powerful in Python.  They permit us to write short, possible nested, loops that result in the creation of a list of objects.  Detailed information about list comprehensions can be found at \url{http://www.python.org/dev/peps/pep-0202/}
\begin{lstlisting}
: [i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
: [i**2 for i in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
: [i**2 for i in range(10) if i%2==0]
[0, 4, 16, 36, 64]
: [i**2 if i%2==0 else i for i in range(10)]
[0, 1, 4, 3, 16, 5, 36, 7, 64, 9]
: [(i,j) for i in range(3) for j in range(5, 7)]
[(0, 5), (0, 6), (1, 5), (1, 6), (2, 5), (2, 6)]
\end{lstlisting}
List comprehensions should not be used when clarity will be sacrificed.  It would be counterproductive to maintain a complex list comprehension that could have been written as a regular \li{for} loop.

One might be tempted to do the following to create a list of ten $1$s.
\begin{lstlisting}
: l = []
: for x in range(10):
:     l.append(1)
: for x in range(5):
:     l.append(8)
\end{lstlisting}
The same can be done with the following.  The plus operator on lists means concatenate and the
multiplication operator on lists means repeat or tile.
\begin{lstlisting}
: l = [1]*10+[8]*5
\end{lstlisting}

\subsection*{List Iteration}
Python contains a handful of really nice ways to iterate though lists.

When iterating though lists, it is recommended to iterate by object rather than by index.
However, if indexes are needed, using \li{enumerate} is highly suggested.
\begin{lstlisting}
: a = list(`abcdefghijklmnopqrstuvwxy')

#iterate by index
: for i in range(len(a)):
:     print a[i],
a b c d e f g h i j k l m n o p q r s t u v w x y z

#iterate by object
: for l in a:
:     print l,
a b c d e f g h i j k l m n o p q r s t u v w x y z

#using enumerate
: for i in enumerate(a):
:     print i,
(0, `a') (1, `b') (2, `c') (3, `d') (4, `e') (5, `f') 
(6, `g') (7, `h') (8, `i') (9, `j') (10, `k') (11, `l') 
(12, `m') (13, `n') (14, `o') (15, `p') (16, `q') (17, `r') 
(18, `s') (19, `t') (20, `u') (21, `v') (22, `w') 
(23, `x') (24, `y') (25, `z')
\end{lstlisting}

When iterating a list in reverse it is advisable to use the \li{reversed()} function.
\begin{lstlisting}
: a = range(100)
: timeit for x in reversed(a): pass
#Do not do this.  It creates a copy of the list to iterate through.
: timeit for x in a[::-1]: pass
\end{lstlisting}

To quickly eliminate duplicates from a list, the best way is to convert to a \li{set}
and then back to list.
\begin{lstlisting}
: a = [1,1,5,2,3,6,43,32,2,43,65,6,3,2,1,1,1]
: a = list(set(a))
\end{lstlisting}

\begin{problem}
Compare the time needed to complete each operation below on sets, tuples, lists, and dictionaries.
\begin{enumerate}
\item Membership: Testing to see if an element is in the sequence
\item Insertion/Remove: Insert an element at beginning middle a
\item Sorting: Note that the underlying data structures for sets and dictionaries keep the keys in sorted order.
\end{enumerate}

\end{problem}



\begin{itemize}
\item Comprehensions (lists, sets, dicts, tuples)
\item Strings+formatting
\item Generators
\item == vs is
\end{itemize}