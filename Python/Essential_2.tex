\lab{Essentials}{NumPy}{NumPy}
\label{lab:Essentials2}

%Talk about
% 1. NumPy

\section*{NumPy}
NumPy is a fundamental package for scientific computing with Python.  It provides an efficient $n$-dimensional array object for fast computations.  This lab will focus on how to use these powerful objects.  NumPy is commonly imported as shown below.

\begin{lstlisting}
: import numpy as np
\end{lstlisting}

Before beginning this lab, it will be useful to understand certain concepts and terms used to describe NumPy arrays.

\subsection*{$N$-Dimensions}
One, two, and three dimensional arrays are easy to visualize.  But how do we visualize a four, ten, or fifteen dimensional array?  NumPy arrays are best thought of as arrays within arrays.  A one dimensional array consists of only elements.  A two dimensional array is really just an array containing arrays which contain elements.  Extending this metaphor, a three dimensional array is an array of arrays of arrays.  Can you guess what a five dimensional array is?  Let's define a three dimensional array.

\begin{lstlisting}
: arr = np.random.randint(50, size=(5, 4, 3))
\end{lstlisting}

Arrays have several attributes.  We use \emph{shape} and \emph{size} to describe the how big an array is.  \emph{Shape} tells how how many dimensions an array has and how big each dimension is.  \emph{Size} gives the total number of elements in the array.

\begin{lstlisting}
: arr.shape
(5, 4, 3)
: arr.size
60
\end{lstlisting}

If we want to know how much memory an array takes to store, we can use \li{arr.nbytes}.  The number of bytes is dependent on the data type (\emph{dtype}) of the array.  The data types that NumPy uses are different from Python data types.  An integer in NumPy is not the same as an integer Python.  Remembering this is vital.  NumPy uses machine data types to speed up calculations.  However, these datatypes are susciptible to a problem called \emph{overflow}.  A 64 bit integer has enough bits to represent integers between $–9,223,372,036,854,775,808$ and $9,223,372,036,854,775,807$.  If we have an array with $–9,223,372,036,854,775,808$ and we decide to subtract $1$, the integer wraps around and becomes $9,223,372,036,854,775,807$!  

\begin{lstlisting}
: arr.dtype
dtype('int64')
: arr.nbytes
480
\end{lstlisting}

Each element of the array has a unique address that describes it location.  Indexing always starts at $0$.  Also, like Python lists, negative indices are valid and count from the tail of the array.  We will discuss indexing in detail later in this lab.

\begin{lstlisting}
: arr[0, 0, 0] # returns the first element of arr
: arr[-1, -1, -1] #returns the last element of arr
\end{lstlisting}

\section*{Creating Arrays}
NumPy has several methods for creating and initializing arrays.  When creating an array, we can optionally specify the data type that is stored in the array.  NumPy arrays only store elements of the same data type, however, that data type can be any arbitrary object.  The array order dictates how the array is laid out in memory.  There is C order and Fortran order.  C ordered arrays are also known as row-major arrays.  This means that the fastest changing index correspond to the rows of the array.  Fortran ordered arrays are column-major.  Let's look at a few of the ways we can create arrays in NumPy.
\begin{itemize}
\item \li{np.array}: Makes an array from a Python list or tuple.
\item \li{np.empty}: Allocates an array of a specific size without initializing the elements.
\item \li{np.ones}: Allocates and array and initializes each element to $1$.
\item \li{np.zeros}: Allocates and array and initializes each element to $0$.
\item \li{np.identity}: Allocates a 2D array array with the main diagonal initalized to $1$ and zeros everywhere else.
\end{itemize}

\subsection*{Indexing Arrays}
Each element of an array has a unique address that we can use to retrieve that element.  Indexing NumPy arrays is syntatically the same as indexing Python lists.  We will demonstrate on a random 2D array.

\begin{lstlisting}
: arr = np.array(range(25)).reshape(5,5); arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
: arr[0, 0] #access the first element
0
: arr[-1, -1] #access the last element
24
: arr[0] #access the first row
array([0, 1, 2, 3, 4])
: arr[0, ::2]
\end{lstlisting}
