\setcounter{chapter}{-1}
\chapter{Interface}
%\addcontentsline{toc}{chapter}{Interface}

\objective{This lab is designed to introduce you to a scientific computing environment for \ProgrammingLanguage.}

Computation is the muscle of applied mathematics. Regardless of the field of study, inevitably there is a need to utilize computers to answer real world questions.  There exist a variety of tools to tackle these questions.  This course will focus on the use of Python, a general purpose programming language, to answer these questions.  There are three core libraries for Python that make it viable for scientific computing.  These libraries are SciPy, NumPy, and Matplotlib.  These libraries provide access to many optimized algorithms and to well known libraries such as LAPACK.

%blurb about how Python is becoming a major tool in the field of scientific computing.  Cite python site, NASA JPL uses python+scipy, etc.
In this chapter, we will introduce you to Python, SciPy, NumPy, and Matplotlib.  We will explain the basics of Python and how to set up an environment ideal for scientific computing.

\section*{Getting Started}
We will set up our python environment with the following libraries.
\begin{itemize}
\item Python 2.x $(x > 5)$
\item NumPy+SciPy
\item Matplotlib
\item IPython
\item A good editor for editing python files
\end{itemize}

A list of editors for python scripts can be found at \url{http://wiki.python.org/moin/PythonEditors}

\subsubsection*{Python}
We will now describe the setup of Python.  Python can be downloaded from \url{http://www.python.org}.  This text will require Python 2.x.  Download and install the appropriate file for your platform.  This book will use Python 2.7.1.  If you are running Linux, this step is usually not necessary as most Linux distributions ship with Python pre-installed.  If you use Linux, it is highly recommended you install software from your distribution's package repositories.

Next we will need to download and install the NumPy and SciPy libraries.  The installation files can downloaded from their respective websites.  Be sure to download the version that matches your version of Python.  For instance, if you installed Python 2.7.1, then you will need the numpy-xxxxx-py27.exe install file.  Installation should be quick and easy as NumPy and Scipy will automatically detect your Python installation and configure themselves accordingly.

For plotting, we will use the Matplotlib library.  The procedure for installing Matplotlib is very similar to that of NumPy and SciPy.  Again, make sure the version you're downloading matches the version of Python that you have installed.

Finally, we will need to install IPython.  IPython can be downloaded from their website.  Users of Windows will also need to download and install the library PyReadline.

For those who wish escape the technical details of configuring your own environment, there are several pre-configured python environments available.  One such environment is Enthought.  It offers free licenses of it distribution to academic users (students or professors).  Another environment is Python(x,y).  These environments include everything needed for this course and much more.  For Linux and Mac OSX users, SAGE also provides a pre-configured environment that includes these libraries.

One additional tool that we will mention is the Spyder Scientific Computing environment.  This tool provides an interface similar to MATLAB.  Though not required for this course, it is worth looking at.  It requires additional libraries to be installed.

\section*{Introducing Python}
Python syntax is very powerful, but is fun and easy to learn.  One day studying the syntax to Python will be well worth your time.  You should be able to learn and understand most python syntax after a single day.  At the end of this chapter are several helpful resources for learning python.

\subsubsection*{Variables}
Python is dynamically typed.  This means that Python will figure out the type of variable you are using based upon the context.  We can assign variables as follows.  Variables in Python are case-sensitive ('a' is not the same as 'A').
\begin{lstlisting}
a = 15		#an integer
b = 15.		#a float
string = "This is Python"
bool = True
type(a)		#returns <type 'int'>; used for discovering the type of a given variable
\end{lstlisting}

%\subsubsection*{Functions}
%Python functions are defined by the \li{def} keyword.  Notice the colon after the function definition.  This colon tells python to expect a block of code to follow.  Spacing is very important in Python.  Where other languages use brackets to enclose blocks of code, Python uses spacing.  As such, Python will complain if spacing is not correct or is inconsistent.  This language feature forces correct indentation, making Python code very readable.  Here's an example of a python function.
%\begin{lstlisting}
%def myFunction():
%    print "You called?"
%
%myFunction()	#prints: You called? to the console.
%\end{lstlisting}

\subsubsection*{Data Structures}
Python offers three basic data structures (ways to store data): tuples, lists, and dictionaries.  Tuples are a collection of objects.  Once a tuple is defined, it cannot be changed (this is refered to as an immutable collection).  They are represented by parentheses.  Lists are also a collection of objects, but lists are mutable, or changeable.  Lists are represented by square brackets.  Dictionaries store objects in key-value pairs.  Dictionaries are represented by curly braces.  Below are a few examples.
\begin{lstlisting}
#Tuples
t = (3,5,6,2, 'this is a tuple') #a tuple with four integers
l = [3,'this is a list', 5 10]
d = {'name':'dictionary', 'value':'Hi There'}
t[0]	#returns 3
l[-1]	#returns 10 (the last item)
d['name'] 	#returns 'dictionary'
\end{lstlisting}
Note that indexing in Python starts with zero.  That is, the first of item is located at index 0.  Python also allows us to conveniently work backwards from the end of the list using negative indices.

%\subsubsection*{Loops and Conditional Statements}
%Python also two forms of loops.  The \li{while} loop will execute as long as its test condition evaluates to \li{True}.  The \li{for} loop is used for iterating through lists, tuples, and dictionaries.
%\begin{lstlisting}
%a = 0
%while a is not 10:
%    a = a + 1
%    print a
%print "I'm outside the while loop"
%# while loop will continue until a is 10, then print: I'm outside the while loop
%
%for a in [6,5,4,3,2,1,0]:
%    print a
%    if a == 2:
%        print "This is a 2"	#executes if a is 2
%    elif a is 5:
%        print "I'm a 5 now"	#executes if a is 5
%    else:
%        print "Still looking..."	#executes if a is anything else
%print "I'm outside the for loop"
%\end{lstlisting}

\section*{Introducing SciPy and NumPy}
These two libraries form the core of our scientific computing environment.

NumPy is a python library that offers the following features:
\begin{itemize}
\item N-dimensional arrays
\item Very optimized functions for large data sets
\item High precision calculations
\item Array language features (like MATLAB)
\end{itemize}

SciPy is another python library that uses NumPy to offer the following additional features:
\begin{itemize}
\item Advanced Math (signal processing, optimization, statistics, etc)
\item Very optimized functions for large data sets
\item Scikits (similar to toolboxes in MATLAB)
\end{itemize}

\section*{Testing our environment}
We will walk you through some quick tests to demonstrate a working environment.

Start by typing \li{ipython} in your command line.
\begin{lstlisting}
$ ipython
Python 2.7.1 (r271:86832, Apr 15 2011, 12:11:58)
Type "copyright", "credits" or "license" for more information.

IPython 0.10.2 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object'. ?object also works, ?? prints more.

In [1]:
\end{lstlisting}

Our cursor will be waiting for us to type something.  Lets start by loading the scipy library.  If we have everything set up correctly, scipy will import correctly and we will be presented with another prompt.
\begin{lstlisting}
In [1]: import scipy

In [2]:
\end{lstlisting}

Let's try making an array.  This will also signal that numpy is working correctly because arrays are defined in numpy (which is automatically imported by scipy).
\begin{lstlisting}
In [2]: A = scipy.array([[3,3,3],[2,2,2],[1,1,1]]); print A
Out[2]:
array([[3, 3, 3],
       [2, 2, 2],
       [1, 1, 1]])
\end{lstlisting}

IPython allows us to access the help pages for any function in a quick and intuitive way.  Simply pose your command as a question by appending a \li{?} at the end of the command.  Let's read the help page for scipy.eye. (Note: Outside of IPython, the command is \li{help(scipy.eye)}.)
\begin{lstlisting}
In [3]: scipy.eye?
String Form:   <function eye at 0x8762064>
Namespace:        Interactive
File:             /usr/lib/python2.7/site-packages/numpy/lib/twodim_base.py
Definition:       scipy.eye(N, M=None, k=0, dtype=<type 'float'>)
Docstring:
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

    Parameters
    ----------
    N : int
      Number of rows in the output.
    M : int, optional
      Number of columns in the output. If None, defaults to `N`.
    k : int, optional
      Index of the diagonal: 0 (the default) refers to the main diagonal,
      a positive value refers to an upper diagonal, and a negative value
      to a lower diagonal.
    dtype : data-type, optiona
    Returns
    -------
    I : ndarray of shape (N,M)
      An array where all elements are equal to zero, except for the `k`-th
      diagonal, whose values are equal to one.

    See Also
    --------
    identity : (almost) equivalent function
    diag : diagonal 2-D array from a 1-D array specified by the user.

    Examples

    Examples
    --------
    >>> np.eye(2, dtype=int)
    array([[1, 0],
           [0, 1]])
    >>> np.eye(3, k=1)
    array([[ 0.,  1.,  0.],
           [ 0.,  0.,  1.],
           [ 0.,  0.,  0.]])
\end{lstlisting}

\section*{Using Python}
Now that we have a working environment, let's learn how to use in the context of this course.

We will be writing and executing many programs written in Python.  How do we accomplish this?  Python programs are contained in files using a *.py extension.  Any number of functions can be contained in these files.  They are executed from the commandline using the following command (where \li{program.py} is the name of the program we want to execute):
\begin{lstlisting}
$ python program.py
\end{lstlisting}

We can treat our programs as libraries (as you will see near the end of this chapter with the benchmarking function).

\section*{Using SciPy}
SciPy is organized into base library with other libraries to handle special features.  We can import these other libraries whenever we need to use them.  Most of the functions we use in this book come from the scipy, linalg, and sparse libraries.

When we use SciPy in book, it will always be imported as follows
\begin{lstlisting}
import scipy as sp
\end{lstlisting}

This imports all the main SciPy methods for use and make them available in the \li{sp} object.  To use the linear algebra library, we use this:
\begin{lstlisting}
from scipy import linalg as la
\end{lstlisting}

Now we have all the linear algebra methods of SciPy accessible under the \li{la} object.

The different libraries available in SciPy are:
\begin{lstlisting}
scipy.cluster: Clustering package
scipy.constants: Constants
scipy.fftpack: Fourier transforms
scipy.integrate: Integration and ODEs
scipy.interpolate: Interpolation
scipy.io: Input and output
scipy.linalg: Linear algebra (imported as la)
scipy.maxentropy: Maximum entropy models
scipy.misc: Miscellaneous routines
scipy.ndimage: Multi-dimensional image processing
scipy.odr: Orthogonal distance regression
scipy.optimize: Optimization and root finding
scipy.signal: Signal processing
scipy.sparse: Sparse matrices (imported as spar)
scipy.sparse.linalg: Sparse linear algebra (imported as sparla)
scipy.spatial: Spatial algorithms and data structures
scipy.spatial.distance: Distance computations
scipy.special: Special functions
scipy.stats: Statistical functions
scipy.weave: C/C++ integration
\end{lstlisting}

\section*{Matplotlib}
SciPy does not provide methods for generating graphics (plots, graphs, etc.).  Matplotlib is a libary written for Python to provide a MATLAB like plotting environment.  If you are familiar with plotting in MATLAB, Matplotlib should be easy to use.  In this course we will be importing Matplotlib as follows.
\begin{lstlisting}
from matplotlib import pyplot as plt
\end{lstlisting}

\section*{A Note on Floating Point Arithmetic}

In mathematics we expect that the difference between two equal quantities to be zero.  For example, $10 - 10 = 0$.  floating point arithmetic isn't always so precise - altering the previous expression to $e^{log(10)} - 10 = 0$ changes nothing on paper, but try putting it into IPython:

\begin{lstlisting}
: 10 - 10
0
: scipy.exp(scipy.log(10))-10
1.7763568394002505e-15
\end{lstlisting}

This is due to floating point arithmetic. Floating point numbers do not have arbitrary precision: they only occupy a certain amount of memory.  For numbers with long decimal expressions or irrational numbers, there will inevitably be a loss of precision because of this memory constraint.  Although these errors will generally be small it is important to understand this limitation of numerical computation. The intricacies of floating point arithmetic will be further developed in Volume II of this work.

Another thing to watch out for is integer division.  It is common in programming to return an integer when dividing two integers.  Type \li{a \= 1/2} into IPython.  What do you expect the value of \li{a} to be?  If you're thinking 0.5, that is incorrect.  Type \li{print a}.  Notice that it returns \li{0}.  This is because both 1 and 2 are integers, so dividing them produces 0.5.  But we want an integer (or so Python assumes), so it simply truncates the result so it is an integer, namely 0.  To get 0.5 (a floating point number), we need to tell Python that 1 or 2 should be treated as a float.  Type \li{b = 1.0/2; print b}.  Now the result is 0.5.

\section*{Timing Code}

As a final note, there are several methods for timing code. This will be important, since throughout this book we stress understanding the intrinsic complexity of different methods for solving problems. We have provided a {\tt timer} class (which you will have to download), that makes the python timing interface easier to use. We will also make use of the {\tt tictoc} class at times, which essentially provides a stopwatch for us to make more crude measurements. We explain how to use these methods as they arise.

%
%Need to talk about timeit
%\section*{Benchmarking}
%Before we continue, there is one more thing we need to discuss.  Throughout this book, you will be asked to compare execution times of different pieces of code.  IPython allows us to easily do this from the console using the \li{\%timeit} command.
%\begin{lstlisting}
%: %timeit [a**3 for a in range(30)]
%100000 loops, best of 3: 11.5 us per loop
%\end{lstlisting}
%The \li{\%timeit} command wraps a Python module called \li{timeit}.  This module will execute a statement many times, timing it each time, and report the best execution time.  The reason for multiple timed executions is to account for random system variances which may affect the performance of function.  Also note that \li{timeit} will disable Python's garbage collector during the tests (the garbage collector is Python's automatic memory manager).  We see above that out of 3 million executions (100000 loops repeated 3 times), the fastest time per loop was 11.5 microseconds.  We can even do functions.
%
%The problem arises when trying to use \li{timeit} directly.  It is tricky to use.  The authors of this book have written a Python module that wraps \li{timeit} into an easy to use Python context.  Please save the following code into an easily accessible file.
%
%\lstinputlisting[style=python, style=fromfile, name=timer.py]{./Source/timer.py}
%
%The reader is not expected to understand the above function (though it would be worthwhile study it).  It uses a feature of Python called contexts.  Consider the following code.
%\begin{lstlisting}
%from timer import timer
%with timer() as t:
%    t.time(myFunction)
%\end{lstlisting}
%
%Python contexts are used via the \li{with} keyword.  In the above code, we initialize the \li{timer()} context which returns to us a \li{timer()} object bound to the variable \li{t}.  Inside the block, we can execute anything.  If we wish to time a specific function we call the \li{time()} method of \li{t}.  The \li{time()} method accepts a function and its parameters and retuns the best execution time (in the form of a string) in the following form:
%\begin{lstlisting}
%myFunction finished in 0.00283s (1 loops, repeated 3 times): 0.00283s per loop (with gc.disable())
%\end{lstlisting}

\section*{Helpful Resources}
\subsubsection*{Python}
\noindent \emph{Dive into Python}:  This python book is a great resource for beginning to understand python.  It is available for for free download. \url{http://diveintopython.org/}

\noindent \emph{Non-Programmer's Tutorial for Python}: \url{http://en.wikibooks.org/wiki/Non-Programmer\%27s_Tutorial_for_Python}

\noindent \emph{The Python Tutorial}: Written by the creator of Python. \url{http://docs.python.org/tutorial/}

\subsubsection*{NumPy and SciPy}
\noindent \emph{NumPy Reference Manual}: \url{http://docs.scipy.org/doc/numpy-1.5.x/reference/}

\noindent \emph{SciPy Reference Manual}: \url{http://docs.scipy.org/doc/scipy-0.9.0/reference/}

\noindent \emph{NumPy for MATLAB Users}: Comparing and contrasting Python and MATLAB. \url{http://www.scipy.org/NumPy_for_Matlab_Users}

\noindent \emph{MATLAB to NumPy translation table}: A table with MATLAB commands and their equivalent NumPy functions.   \url{http://mathesaurus.sourceforge.net/matlab-numpy.html}

\noindent \emph{NumPy and SciPy Cookbook}: \url{http://www.scipy.org/Cookbook}

\noindent \emph{Introduction to Arrays}: Very informative introduction the SciPy arrays. \url{http://pages.physics.cornell.edu/~myers/teaching/ComputationalMethods/python/arrays.html}

\subsubsection*{Matplotlib}
\noindent \emph{Matplotlib User Guide}: \url{http://matplotlib.sourceforge.net/contents.html}

\noindent \emph{Matplotlib Examples}: Useful for seeing the python code that generate certain plots. \url{http://matplotlib.sourceforge.net/examples/index.html}



