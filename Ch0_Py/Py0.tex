\setcounter{chapter}{-1}
\chapter{Getting Started}
%\addcontentsline{toc}{chapter}{Interface}

\objective{An introduction to scientific computing using Python.}

%Latter half of paragraph needs rewording.  Feels rather awkward to read.
This course focuses on the use of computers in solving mathematical problems.  In today's world, many problems that we wish to solve are so large and complex that to solve them by hand would be infeasible.  To be able to effectively use computers to solve these huge problems is becoming a highly demanded skill.  As you work through these labs, you will learn how to use computers to work through complicated problems.  We can say that computation is the muscle of applied mathematics.

These courses will use a powerful yet simple to use programming language called Python as an interface to optimized numerical libraries.  This chapter will walk you through setting up a scientific computing environment based on Python.  All the libraries are freely available on the internet as open source software.

Computation is the muscle of applied mathematics. Regardless of the field of study, inevitably there is a need to utilize computers to answer real world questions.  There exist a variety of tools to tackle these questions.  This course will focus on the use of Python, a powerful, general purpose programming language, to answer these questions.  There are three core libraries for Python that make it viable for scientific computing.  These libraries are SciPy, NumPy, and Matplotlib.  These libraries provide access to many optimized algorithms and to well known libraries such as LAPACK.

\section*{Getting Started}
We will set up our Python environment with the following libraries.
\begin{itemize}
\item Python 2.5 or greater
\item NumPy and SciPy
\item Matplotlib
\item IPython
\item A good editor for editing Python files
\end{itemize}

\noindent A list of editors for python scripts can be found at \url{http://wiki.python.org/moin/PythonEditors}

\subsection*{Python}
\url{http://www.python.org}

Let's begin by setting up Python.  This text recommends the use Python 2.7, but any Python version greater than 2.5 should work just as well.  Download and install the appropriate installation file for your platform.  If you are running Linux, this step is usually not necessary as most Linux distributions ship with Python pre-installed.  NOTE: On Linux, it is highly recommended you install software from your distribution's package repositories.

\subsection*{Numpy and Scipy}
Numpy: \url{http://numpy.scipy.org/}

\noindent Scipy: \url{http://www.scipy.org/}

Numpy is a fundamental library for scientific computating.  It adds the following features to Python.
\begin{itemize}
\item Efficient N-dimensional arrays
\item Very optimized functions designed for working with large data sets
\item High precision calculations
\item Array language features (like MATLAB)
\end{itemize}

SciPy is another python library that uses NumPy to offer the following additional features.
\begin{itemize}
\item Advanced math (signal processing, optimization, statistics, etc)
\item Very optimized functions for large data sets
\item Scikits (similar to toolboxes for MATLAB)
\end{itemize}

We can obtain both libraries from their respective websites.  Be sure to download the version that matches your version of Python.  For instance, if you installed Python 2.7.1, then you will need the numpy-xxxxx-py27.exe install file.  Installation should be quick and easy as NumPy and Scipy will automatically detect your Python installation and configure themselves accordingly.

\subsection*{Matplotlib}
\url{http://matplotlib.sourceforge.net/}

Matplotlib is a 2D plotting library for Python.  It produces publication quality plots and graphs.
For plotting, we will use the Matplotlib library.  The procedure for installing Matplotlib is very similar to that of NumPy and SciPy.  Again, make sure the version you're downloading matches the version of Python that you have installed.

\subsection*{IPython}
\url{http://ipython.org/}

Finally, we will need to install IPython.  IPython can be downloaded from their website.  Users of Windows will also need to download and install the library PyReadline (a straightfoward process that matches the previous two installations).

For those who wish escape the technical details of configuring your own environment, there are several pre-configured python environments available.  One such environment is Enthought.  It offers a free edition that includes these libraries and more.  Another environment is Python(x,y).  These environments include everything needed for this course and much more.  For Linux and Mac OSX users, SAGE also provides a pre-configured environment that includes these libraries.

One additional tool that we will mention is the Spyder Scientific Computing environment.  This tool provides an interface similar to MATLAB.  Though not required for this course, it is worth looking at.  It requires additional libraries to be installed.

\section*{Introducing Python}
Python syntax is very powerful, but is fun and easy to learn.  One day devoted to studying the syntax to Python will be well worth your time.  You should be able to learn and understand most python syntax after a single day.  At the end of this chapter are several helpful resources for learning python.

\subsection*{Data Types}
Computer programs store and manuipate data.  This data is stored in various forms that makes it easy to work with.  Python has native support for several powerful data types.
%Python is dynamically typed.

\subsubsection*{Numeric and Boolean Types}
Python has native support for integers, floats, and complex numbers.  The standard arithmetic operations are supported for each type.
\begin{lstlisting}[style=python]
 a = 15         #an integer
 b = 15.0       #a float
 c = 15+1j      #complex number
\end{lstlisting}

Boolean types have only two possible values: \li{True} or \li{False}.

\subsubsection*{Container Types}
Powerful container types add to the flexibility of Python.  The container types include:
\begin{itemize}
 \item Tuples
 \item Lists
 \item Dictionaries
 \item Sets
\end{itemize}

\paragraph{Tuples}
Tuples are just like lists except that tuples cannot be have items added or removed.  Once created, a tuple can never change.  Why use tuples over lists?  Tuples have less overhead than lists.  


Once a tuple is defined, it cannot be changed (this is referred to as an immutable sequence).  They are represented by parentheses.  Lists are also sequences of objects, but lists are mutable, or changeable.  Lists are represented by square brackets.  Dictionaries store objects in key-value pairs.  Dictionaries are represented by curly braces.  Below are a few examples.
\begin{lstlisting}[style=python]
#Tuples
t = (3,5,6,2, 'this is a tuple') #a tuple with four integers
l = [3,'this is a list', 5 10]
d = {'name':'dictionary', 'value':'Hi There'}
t[0]    #returns 3
l[-1]   #returns 10 (the last item)
d['name']       #returns 'dictionary'
\end{lstlisting}
Note that indexing in Python starts with zero.  That is, the first of item is located at index 0.  Python also allows us to conveniently work backwards from the end of the list using negative indices.

\paragraph{Lists}
Lists are like arrays in that they store ordered sequences of objects.  This datatype is Python's workhorse datatype.  They are incredible useful and efficient.  Mastery of lists will greatly increase your productivity in Python.  The arrays that we will be using later in this course follow the same conventions as lists in Python.  So master lists, and you will be confident working with NumPy arrays!  To create a list we use square brackets around a comma separated list of objects.  They objects can be of any type (they don't all even have to be of the same type).  We initialize a list with 4 objects: an integer, a string, a float and a boolean.
\begin{lstlisting}[style=python]
a_list = [3, 'string', 50.0, True]
\end{lstlisting}
Now, how do we gain access to these elements in the list?  Lists are indexed with integer indices just like arrays. So \li{a_list[0]} will return the first object in the list (the integer \li{3}).  Lists can also be accessed from the end using negative indices (\li{a_list[-1]} returns the boolean \li{True}).

Accessing single elements of the list is great, but what if we what a subset of the list?  This is also very simple.  We can request a subset of any list in Python by slicing the list.  We slice a list using the form \li{a_list[start:end]}.  This will return another list containing the elements of the original list beginning with \emph{start} up to, but not including \emph{end}.  When \emph{start} is 0 or \emph{end} is the -1, we can omit them such as \li{a_list[:3]} and \li{a_list[1:]} because the are implied.  To make a copy of the entire list we can do \li{a_list[:]}.

Now that we can create and slice lists, how do we change the contents of a list?  This is also very simple to do.
\begin{lstlisting}[style=python]
alist = []      #begin with empty list
alist = alist+[1, True] #alist = [1, True]
alist.append(5)           #alist = [1, True, 5]
alist.insert(0,'hi')      #alist = ['hi', 1, True, 5]
alist.extend([0,1,2])     #alist = ['hi', 1, True, 5, 0, 1, 2]
\end{lstlisting}
This listing show how we can add two lists together, append an item at the end, insert an item at a certain index, or extend a list with another list.

Removing items from a list is simple too!  Consider the following listing.
\begin{lstlisting}[style=python]
#alist = ['hi', 1, True, 5, 0, 1, 2]
alist.remove(1)
#alist = ['hi', True, 5, 0, 1, 2]
alist.remove(1)
#alist = ['hi', True, 5, 0, 2]
alist.pop(0)    #returns the item it removed from the list
#alist = [True, 5, 0, 2]
\end{lstlisting}
Those are the basics of Python lists.

\paragraph{Dictionaries}
Dictionaries store data in key-value pairs.  The keys of a dictionary must be unique.  The values can be any data type.

\paragraph{Sets}
Sets are a collection of unordered, unique items.  Very close to the mathematical definition of a set.

\subsubsection*{Functions}
Python functions are defined by the \li{def} keyword.  Notice the colon after the function definition.  This colon tells python to expect a block of code to follow.  Spacing is very important in Python.  Where other languages use brackets to enclose blocks of code, Python uses spacing to define blocks of code.  As such, Python will complain if spacing is not correct or is inconsistent.  This language feature forces correct indentation, making Python code very readable.  Here's an example of a python function.
\begin{lstlisting}[style=python]
def myFunction():
   print "You called?"

myFunction()	#prints: You called? to the console.
\end{lstlisting}

\subsubsection*{Loops and Conditional Statements}
Python also two forms of loops.  The \li{while} loop will execute as long as its test condition evaluates to \li{True}.  The \li{for} loop is used for iterating through lists, tuples, and dictionaries.
\begin{lstlisting}
a = 0
while a is not 10:
   a = a + 1
   print a
print "I'm outside the while loop"
# while loop will continue until a is 10, then print: I'm outside the while loop

for a in [6,5,4,3,2,1,0]:
   print a
   if a == 2:
       print "This is a 2"	#executes if a is 2
   elif a is 5:
       print "I'm a 5 now"	#executes if a is 5
   else:
       print "Still looking..."	#executes if a is anything else
print "I'm outside the for loop"
\end{lstlisting}

\section*{Testing our environment}
We will walk you through some quick tests to demonstrate a working environment.

Start by typing \li{ipython} in your command line.
\begin{lstlisting}
$ ipython
Python 2.7.2 (default, Jun 29 2011, 11:17:09) 
Type "copyright", "credits" or "license" for more information.

IPython 0.11 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: 
\end{lstlisting}

Our cursor will be waiting for us to type something.  Lets start by loading the SciPy library.  If we have everything set up correctly, SciPy will import correctly and we will be presented with another prompt.
\begin{lstlisting}[style=python]
In [1]: import scipy

In [2]:
\end{lstlisting}

Let's try making an array.  This will also signal that NumPy is working correctly because arrays are defined in NumPy (NumPy is automatically imported by SciPy).
\begin{lstlisting}[style=python]
In [2]: A = scipy.array([[3,3,3],[2,2,2],[1,1,1]]); print A
Out[2]:
array([[3, 3, 3],
       [2, 2, 2],
       [1, 1, 1]])
\end{lstlisting}

IPython allows us to access the help pages for any function in a quick and intuitive way.  Simply pose your command as a question by appending a \li{?} at the end of the command.  To view the source code of the function (if available), use two question marks. Let's read the help page for scipy.eye. (Note: Outside of IPython, the command is \li{help(scipy.eye)}.)
\begin{lstlisting}
In [3]: scipy.eye?
String Form:   <function eye at 0x8762064>
Namespace:        Interactive
File:             /usr/lib/python2.7/site-packages/numpy/lib/twodim_base.py
Definition:       scipy.eye(N, M=None, k=0, dtype=<type 'float'>)
Docstring:
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

    Parameters
    ----------
    N : int
      Number of rows in the output.
    M : int, optional
      Number of columns in the output. If None, defaults to `N`.
    k : int, optional
      Index of the diagonal: 0 (the default) refers to the main diagonal,
      a positive value refers to an upper diagonal, and a negative value
      to a lower diagonal.
    dtype : data-type, optional
    Returns
    -------
    I : ndarray of shape (N,M)
      An array where all elements are equal to zero, except for the `k`-th
      diagonal, whose values are equal to one.

    See Also
    --------
    identity : (almost) equivalent function
    diag : diagonal 2-D array from a 1-D array specified by the user.

    Examples

    Examples
    --------
    >>> np.eye(2, dtype=int)
    array([[1, 0],
           [0, 1]])
    >>> np.eye(3, k=1)
    array([[ 0.,  1.,  0.],
           [ 0.,  0.,  1.],
           [ 0.,  0.,  0.]])
\end{lstlisting}

\section*{Using Python}
Now that we have a working environment, let's learn how to use in the context of this course.

We will be writing and executing many programs written in Python.  How do we accomplish this?  Python programs are contained in files using a *.py extension.  Any number of functions can be contained in these files.  They are executed from the commandline using the following command (where \li{program.py} is the name of the program we want to execute):
\begin{lstlisting}
$ python program.py
\end{lstlisting}

We can treat our programs as libraries (as you will see near the end of this chapter with the benchmarking function).

\section*{Using SciPy}
SciPy is organized into base library with other libraries to handle special features.  We can import these other libraries whenever we need to use them.  Most of the functions we use in this book come from the scipy, linalg, and sparse libraries. The different libraries available in SciPy are:
\begin{lstlisting}
scipy.cluster: Clustering package
scipy.constants: Constants
scipy.fftpack: Fourier transforms
scipy.integrate: Integration and ODEs
scipy.interpolate: Interpolation
scipy.io: Input and output
scipy.linalg: Linear algebra (imported as la)
scipy.maxentropy: Maximum entropy models
scipy.misc: Miscellaneous routines
scipy.ndimage: Multi-dimensional image processing
scipy.odr: Orthogonal distance regression
scipy.optimize: Optimization and root finding
scipy.signal: Signal processing
scipy.sparse: Sparse matrices (imported as spar)
scipy.sparse.linalg: Sparse linear algebra (imported as sparla)
scipy.spatial: Spatial algorithms and data structures
scipy.spatial.distance: Distance computations
scipy.special: Special functions
scipy.stats: Statistical functions
scipy.weave: C/C++ integration
\end{lstlisting}

When we use SciPy in book, it will always be imported as follows. This python statement imports all the main SciPy methods for use and make them available in the \li{sp} object.
\begin{lstlisting}
import scipy as sp
\end{lstlisting}

To use the SciPy's linear algebra library, we use the following import statement.  After this statement, all the linear algebra methods of SciPy will be available under the \li{la} object.
\begin{lstlisting}
import scipy.linalg as la
\end{lstlisting}

\section*{Matplotlib}
SciPy does not provide methods for generating graphics (plots, graphs, etc.).  Matplotlib is a libary written for Python to provide a MATLAB like plotting environment.  If you are familiar with plotting in MATLAB, Matplotlib should be easy to use.  In this course we will be importing Matplotlib as follows.  Again note that after importing \li{matplotlib.pyplot}, the methods will available under the \li{plt} object.
\begin{lstlisting}
import matplotlib.pyplot as plt
\end{lstlisting}

\section*{A Note on Floating Point Arithmetic}
In mathematics we expect that the difference between two equal quantities to be zero.  For example, $10 - 10 = 0$.  floating point arithmetic isn't always so precise - altering the previous expression to $e^{log(10)} - 10 = 0$ changes nothing on paper, but try putting it into IPython:

\begin{lstlisting}
: 10 - 10
0
: scipy.exp(scipy.log(10))-10
1.7763568394002505e-15
\end{lstlisting}

This is due to floating point arithmetic. Floating point numbers do not have arbitrary precision: they only occupy a certain amount of memory.  For numbers with long decimal expressions or irrational numbers, there will inevitably be a loss of precision because of this memory constraint.  Although these errors will generally be small it is important to understand this limitation of numerical computation. The intricacies of floating point arithmetic will be further developed in Volume II of this work.

Another thing to watch out for is integer division.  It is common in programming to return an integer when dividing two integers.  Type \li{a \= 1/2} into IPython.  What do you expect the value of \li{a} to be?  If you're thinking 0.5, that is incorrect.  Type \li{print a}.  Notice that it returns \li{0}.  This is because both \li{1} and \li{2} are integers, so dividing them produces \li{0}.  To get 0.5 (a floating point number), we need to tell Python that it should treat \li{1} or \li{2} as a float.  Type \li{b = 1.0/2; print b}.  Now the result is 0.5.
There are two ways to force Python to always return a float when dividing.  First we can run a script and pass the \li{-Qnew} option to the Python interpreter.  Second, we can import the following at the top of each script where we wish to use only true division.
\begin{lstlisting}
from __future__ import division
\end{lstlisting}

%\section*{Timing Code}
%As a final note, there are several methods for timing code. This will be important, since throughout this book we stress understanding the intrinsic complexity of different methods for solving problems. We have provided a \li{timer} class (which you will have to download), that makes the python timing interface easier to use. 

\section*{Benchmarking}
Before we continue, there is one more thing we need to discuss.  Throughout this book, you will be asked to compare execution times of different pieces of code.  IPython allows us to easily do this from the console using the \li{\%timeit} command.
\begin{lstlisting}
: %timeit [a**3 for a in range(30)]
100000 loops, best of 3: 11.5 us per loop
\end{lstlisting}
The \li{\%timeit} command wraps a Python module called \li{timeit}.  This module will execute a statement many times, timing it each time, and report the best execution time.  The reason for multiple timed executions is to account for random system variances which may affect the performance of function.  Also note that \li{timeit} will disable Python's garbage collector during the tests (the garbage collector is how Python automatically manages memory).  We see above that out of 3 million executions (100000 loops repeated 3 times), the fastest time per loop was 11.5 microseconds.  We can even time the execution of functions.

The problem with \li{\%timeit} is that it is only defined inside ipython.  The authors of this book have written a Python module that wraps \li{timeit} into an easy to use Python context.  Please save the following code into an easily accessible file.

\lstinputlisting[style=python, style=fromfile, name=mytimer.py]{mytimer.py}

The reader is not expected to understand the above function (though it would be worthwhile study it).  It uses a feature of Python called contexts.  Consider the following code.
\begin{lstlisting}
from mytimer import timer
with timer() as t:
    t.time(myFunction, arguments)
    t.printTimes()
\end{lstlisting}

Python contexts are used via the \li{with} keyword.  In the above code, we initialize the \li{timer()} context which returns to us a \li{timer()} object bound to the variable \li{t}.  Inside the block, we can execute anything.  If we wish to time a specific function we call the \li{time()} method of \li{t}.  The \li{time()} method accepts a function and its parameters and returns the best execution time (in the form of a string) in the following form:
\begin{lstlisting}
myFunction finished in 0.00283s (1 loops, repeated 3 times): 0.00283s per loop (with gc.disable())
\end{lstlisting}

\section*{Helpful Resources}
\subsubsection*{Python}
\noindent \emph{Dive into Python}:  This python book is a great resource for beginning to understand python.  It is available for for free download. \url{http://diveintopython.org/}

\noindent \emph{Non-Programmer's Tutorial for Python}: \url{http://en.wikibooks.org/wiki/Non-Programmer\%27s_Tutorial_for_Python}

\noindent \emph{The Python Tutorial}: Written by the creator of Python. \url{http://docs.python.org/tutorial/}

\subsubsection*{NumPy and SciPy}
\noindent \emph{NumPy Reference Manual}: \url{http://docs.scipy.org/doc/numpy-1.6.0/reference/}

\noindent \emph{SciPy Reference Manual}: \url{http://docs.scipy.org/doc/scipy-0.9.0/reference/}

\noindent \emph{NumPy for MATLAB Users}: Comparing and contrasting Python and MATLAB. \url{http://www.scipy.org/NumPy_for_Matlab_Users}

\noindent \emph{MATLAB to NumPy translation table}: A table with MATLAB commands and their equivalent NumPy functions.   \url{http://mathesaurus.sourceforge.net/matlab-numpy.html}

\noindent \emph{NumPy and SciPy Cookbook}: \url{http://www.scipy.org/Cookbook}

\noindent \emph{Introduction to Arrays}: Very informative introduction the SciPy arrays. \url{http://pages.physics.cornell.edu/~myers/teaching/ComputationalMethods/python/arrays.html}

\subsubsection*{Matplotlib}
\noindent \emph{Matplotlib User Guide}: \url{http://matplotlib.sourceforge.net/contents.html}

\noindent \emph{Matplotlib Examples}: Useful for seeing the python code that generate certain plots. \url{http://matplotlib.sourceforge.net/examples/index.html}



